#
# This file defines probes for local features that vmalloc requires.
# Such probes are interpreted by the "iffe" language interpreter.
# Results are stored in the FEATURE directory. Some of the
# {lib,hdr,sys,typ} tests may also be done in the AST features/lib;
# repeating them here allows for single standalone and AST sources.
#

ref	-D_def_map_ast=1

lib	atexit,getpagesize,mallinfo,mallopt,memalign,mstats
lib	onexit,pvalloc,strdup,valloc,vmalloc
lib	_malloc,__malloc,__libc_malloc
hdr	alloca,malloc,stat,stdlib,unistd
mem	mallinfo.arena,mstats.bytes_total malloc.h
sys	stat
typ	ssize_t

tst	mem_sbrk note{ sbrk() works as expected }end execute{
	#include        <sys/types.h>
	#include        <unistd.h>
	#undef	uchar
	#define	uchar	unsigned char
	int main()
	{	uchar	*brk0, *brk1;
		int	chg;

		/* allocate a big chunk */
		if(!(brk0 = (uchar*)sbrk(0)) || brk0 == (uchar*)(-1))
			return 1;
		chg = 256 * 1024;
		brk0 += chg;
		if(sbrk(chg) == ((void*)-1))
			return 1;
		if((brk1 = (uchar*)sbrk(0)) != brk0)
			return 1;

		/* now return half of it */
		chg /= 2;
		brk1 -= chg;
		if(sbrk(-chg) == ((void*)-1))
			return 1;
		if((brk0 = (uchar*)sbrk(0)) != brk1)
			return 1;

		return 0;
	}
}end

tst	map_malloc note{ map malloc to _ast_malloc }end noexecute{
	#if __CYGWIN__
	int main() { return 1; }
	#else
	static int user = 0;
	_BEGIN_EXTERNS_
	#if _lib_strdup
	extern char* strdup _ARG_((const char*));
	#define LOCAL()	strdup("s")
	#else
	extern void* calloc _ARG_((unsigned int, unsigned int));
	#define LOCAL()	calloc(1,1)
	#endif
	#if __CYGWIN__
	#define extern __declspec(dllexport)
	#endif
	#define HT double
	static HT heap[1024 * 4];
	static HT* hp = &heap[1];
	static HT* op;
	#define MALLOC(n) if(user)return&heap[0];op=hp;hp+=(n+sizeof(HT)-1)/sizeof(HT);return(void*)op;
	#define INTERCEPTED(p) (((char*)(p))==((char*)&heap[0]))
	#if _STD_
	extern void free(void* p) { }
	extern void _free(void* p) { }
	extern void __free(void* p) { }
	extern void __libc_free(void* p) { }
	extern void* malloc(unsigned int n) { MALLOC(n); }
	extern void* _malloc(unsigned int n) { MALLOC(n); }
	extern void* __malloc(unsigned int n) { MALLOC(n); }
	extern void* __libc_malloc(unsigned int n) { MALLOC(n); }
	#else
	extern void free(p) char* p; { }
	extern void _free(p) char* p; { }
	extern void __free(p) char* p; { }
	extern void __libc_free(p) char* p; { }
	extern void* malloc(n) unsigned int n; { MALLOC(n); }
	extern void* _malloc(n) unsigned int n; { MALLOC(n); }
	extern void* __malloc(n) unsigned int n; { MALLOC(n); }
	extern void* __libc_malloc(n) unsigned int n; { MALLOC(n); }
	#endif
	_END_EXTERNS_
	int main() { user = 1; return !INTERCEPTED(LOCAL()); }
	#endif
}end

tst	map_malloc note{ map malloc to _ast_malloc -- wimp-o mach? }end noexecute{
	#if _map_malloc
	int main() { return 0; }
	#else
	_BEGIN_EXTERNS_
	#if _STD_
	void* calloc(unsigned n, unsigned m) { exit(1); }
	#else
	void* calloc(n, m) unsigned n, m; { exit(1); }
	#endif
	_END_EXTERNS_
	int main() { return 0; }
	#endif
}end

lib	alloca note{ alloca exists }end link{
	#if _hdr_alloca
	#include	<alloca.h>
	#endif
	int
	main()
	{	alloca(10);
	}
}end

tst	mal_alloca note{ alloca is based on malloc() }end execute{
	#if __CYGWIN__
	int main() { return 1; }
	#else
	#if _hdr_alloca
	#include	<alloca.h>
	#endif
	#if _STD_
	void* malloc(unsigned int size)
	#else
	void* malloc(size) unsigned int size;
	#endif
	{	exit(0);
		return 0;
	}
	int main()
	{	alloca(10);
		return 1;
	}
	#endif
}end

tst	stk_down note{ stack grows downward }end execute{
	static growdown()
	{	static char*	addr = 0;
		char		array[4];
		if(!addr)
		{	addr = &array[0];
			return growdown();
		}
		else if(addr < &array[0])
			return 0;
		else	return 1;	
	}
	int main() { return growdown() ? 0 : 1; }
}end

tst	malloc_hook note{ gnu malloc hooks work }end execute{
	#include <malloc.h>

	static int      	test_free_hit = 0;
	static int      	test_malloc_hit = 0;
	static int      	test_memalign_hit = 0;
	static int      	test_realloc_hit = 0;

	static void test_free_hook(void* ptr, const void* caller)
	{
	        test_free_hit++;
	}

	static void* test_malloc_hook(size_t size, const void* caller)
	{
	        test_malloc_hit++;
	        return 0;
	}

	static void* test_memalign_hook(size_t align, size_t size, const void* caller)
	{
	        test_memalign_hit++;
	        return 0;
	}

	static void* test_realloc_hook(void* ptr, size_t size, const void* caller)
	{
	        test_realloc_hit++;
	        return 0;
	}

	static void test_initialize_hook(void)
	{
	        __free_hook = test_free_hook;
	        __malloc_hook = test_malloc_hook;
	        __memalign_hook = test_memalign_hook;
	        __realloc_hook = test_realloc_hook;
	}

	typeof (__malloc_initialize_hook) __malloc_initialize_hook = test_initialize_hook;

	int main()
	{
	        void*   p;

	        p = malloc(16);
	        p = realloc(p, 32);
	        free(p);
	        p = memalign(32, 32);
	        return !test_free_hit || !test_malloc_hit || !test_memalign_hit || !test_realloc_hit;
	}
}end

cat{
	#include "FEATURE/mmap"
	#if _BLD_INSTRUMENT || cray || _UWIN && _BLD_ast
	#undef	_map_malloc
	#define _std_malloc	1	/* defer to standard malloc */
	#endif
	#if _mmap_anon
	#define _mem_mmap_anon	1
	#endif
	#if _mmap_devzero
	#define _mem_mmap_zero	1
	#endif
}end
