.fp 5 CW
.de MW
\f5\\$1\fP
..
.TH VDELTA 3 "16 July 1994"
.SH NAME
vdelta \- data differencing and compression
.SH SYNOPSIS
.MW "#include <vdelta.h>"
.nf
.MW "long vddelta(Vddisc_t* source, Vddisc_t* target, Vddisc_t* delta);"
.MW "long vdupdate(Vddisc_t* source, Vddisc_t* target, Vddisc_t* delta);"
.MW "int vdsqueeze(Void_t* target, int n, Void_t* delta);"
.MW "int vdexpand(Void_t* target, int n, Void_t* delta);"
.fi
.SH DESCRIPTION
These functions embody an algorithm for determining a compressed form of the
difference between two byte streams,
and for applying that difference to a byte stream.
.PP
.I Vddelta
computes a transformation (encoded as the byte stream \f5delta\fP)
that maps the source byte stream \f5source\fP
to the target byte stream \f5target\fP.
If the source stream is empty (\f5source\fP is \f5NULL\fP or
\f5source->size\fP is non-positive),
\fIvddelta\fP acts like a compression routine.
\fIVddelta\fP returns the length of the transformation byte stream.
.PP
.I Vdupdate
applies a transformation \f5delta\fP generated by
\fIvddelta\fP to the source byte stream \f5source\fP
and emits the target byte stream \f5target\fP.
\fIVdupdate\fP returns the length of the target byte stream.
.PP
.I Vdsqueeze
compresses the string \f5target\fP of length \f5n\fP and outputs
the compressed data to the string \f5delta\fP.
\fIVdsqueeze\fP returns the length of the compressed data.
.PP
.I Vdexpand
decompresses compressed data in \f5delta\fP into the \f5target\fP area
which is of size \f5n\fP.
\fIVdexpand\fP returns the length of the decompressed data.
.PP
The handling of data for a data stream is defined
by a discipline structure of type \f5Vddisc_t\fP.
This type contains the following members:
.in +.5i
.nf
.MW "long size;"
.MW "Void_t* data;"
.MW "int (*readf)(Void_t* buf, int n, long offset, Vddisc_t* disc);"
.MW "int (*writef)Void_t* buf, int n, long offset, Vddisc_t* disc);"
.fi
.in -.5i
.TP
\f5size\fP defines the length of the respective data stream.
.TP
\f5data\fP, if not \f5NULL\fP, is an array that either contains
the entire data for a read stream or is large enough to store
the entire generated data. For example, in the \fIvddelta\fP call,
\f5target->size\fP defines the length of the target stream.
In this case, if \f5target->data\fP is not \f5NULL\fP,
it is assumed to contain all of the target data
(therefore, \f5target->readf\fP is not required.)
.TP
.MW readf
points to a function that reads at most \f5n\fP bytes
into \f5buf\fP from position \f5offset\fP
in the byte stream specified by the  as described above, and
returns the number of bytes actually read, or \-1 on error.
The argument \f5disc\fP is the containing discipline structure.
.TP
.MW writef
is identical to \f5readf\fP except that it writes rather than reads bytes.
.TP
.PP
\f5Void_t\fP is \f5#define\fPd as \f5void\fP if possible, otherwise \f5char\fP.
.SH DIAGNOSTICS
\fIVddelta\fP, \fIvdupdate\fP, \fIvdsqueeze\fP and \fIvdexpand\fP
return \-1 on error.
.SH AUTHORS
Kiem-Phong Vo, kpv@research.att.com, AT&T Bell Laboratories
.br
David G. Korn, dgk@research.att.com, AT&T Bell Laboratories
